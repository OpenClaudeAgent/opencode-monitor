#!/bin/bash
#
# OpenCode Debug Tool
# Enregistre et analyse les evenements/donnees de l'API OpenCode
#
# Usage:
#   opencode-debug record    # Enregistre les evenements en temps reel
#   opencode-debug analyze   # Analyse les logs enregistres
#

set -u

# === Configuration ===
DEBUG_DIR="/tmp/opencode-debug"
POLL_INTERVAL=5  # secondes entre les polls HTTP

# === Couleurs ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m'

# === Helpers ===

log() {
    echo -e "${GRAY}[$(date +%H:%M:%S)]${NC} $1"
}

log_success() {
    echo -e "${GRAY}[$(date +%H:%M:%S)]${NC} ${GREEN}$1${NC}"
}

log_warn() {
    echo -e "${GRAY}[$(date +%H:%M:%S)]${NC} ${YELLOW}$1${NC}"
}

log_error() {
    echo -e "${GRAY}[$(date +%H:%M:%S)]${NC} ${RED}$1${NC}"
}

# Trouve tous les ports OpenCode actifs
find_opencode_ports() {
    /usr/sbin/lsof -i -P 2>/dev/null | awk '/opencode.*LISTEN/ {gsub(/.*:/,"",$9); print $9}' | sort -u
}

# === Mode Record ===

record_sse_events() {
    local port="$1"
    local output_file="$2"
    local url="http://127.0.0.1:${port}/event"
    
    log "  SSE listener started for port $port"
    
    curl -sN "$url" 2>/dev/null | while IFS= read -r line; do
        if [[ "$line" == data:* ]]; then
            local event_data="${line#data: }"
            local timestamp=$(date +%s)
            # Ajoute timestamp et port au JSON
            echo "{\"ts\":$timestamp,\"port\":$port,\"event\":$event_data}" >> "$output_file"
        fi
    done
}

poll_session_status() {
    local port="$1"
    local output_file="$2"
    local url="http://127.0.0.1:${port}/session/status"
    
    local response=$(curl -s --max-time 5 "$url" 2>/dev/null)
    if [[ -n "$response" && "$response" != "null" ]]; then
        local timestamp=$(date +%s)
        echo "{\"ts\":$timestamp,\"port\":$port,\"status\":$response}" >> "$output_file"
    fi
}

poll_session_messages() {
    local port="$1"
    local session_id="$2"
    local output_file="$3"
    local url="http://127.0.0.1:${port}/session/${session_id}/message?limit=1"
    
    local response=$(curl -s --max-time 5 "$url" 2>/dev/null)
    if [[ -n "$response" && "$response" != "null" && "$response" != "[]" ]]; then
        local timestamp=$(date +%s)
        echo "{\"ts\":$timestamp,\"port\":$port,\"session\":\"$session_id\",\"messages\":$response}" >> "$output_file"
    fi
}

poll_session_todos() {
    local port="$1"
    local session_id="$2"
    local output_file="$3"
    local url="http://127.0.0.1:${port}/session/${session_id}/todo"
    
    local response=$(curl -s --max-time 5 "$url" 2>/dev/null)
    if [[ -n "$response" && "$response" != "null" && "$response" != "[]" ]]; then
        local timestamp=$(date +%s)
        echo "{\"ts\":$timestamp,\"port\":$port,\"session\":\"$session_id\",\"todos\":$response}" >> "$output_file"
    fi
}

do_record() {
    local session_dir="$DEBUG_DIR/$(date +%Y-%m-%d_%H-%M-%S)"
    mkdir -p "$session_dir"
    
    local events_file="$session_dir/events.jsonl"
    local status_file="$session_dir/poll-status.jsonl"
    local messages_file="$session_dir/poll-messages.jsonl"
    local todos_file="$session_dir/poll-todos.jsonl"
    
    # Initialise les fichiers
    touch "$events_file" "$status_file" "$messages_file" "$todos_file"
    
    echo ""
    log_success "=== OpenCode Debug Recorder ==="
    log "Output directory: $session_dir"
    echo ""
    
    # Track SSE listener PIDs
    declare -A SSE_PIDS
    
    cleanup() {
        echo ""
        log_warn "Stopping..."
        for pid in "${SSE_PIDS[@]}"; do
            kill "$pid" 2>/dev/null
        done
        
        # Genere le summary
        local event_count=$(wc -l < "$events_file" | tr -d ' ')
        local status_count=$(wc -l < "$status_file" | tr -d ' ')
        local messages_count=$(wc -l < "$messages_file" | tr -d ' ')
        local todos_count=$(wc -l < "$todos_file" | tr -d ' ')
        
        cat > "$session_dir/summary.json" << EOF
{
  "recorded_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "duration_seconds": $SECONDS,
  "counts": {
    "events": $event_count,
    "status_polls": $status_count,
    "message_polls": $messages_count,
    "todo_polls": $todos_count
  }
}
EOF
        
        echo ""
        log_success "Recording complete!"
        log "  Events:   $event_count"
        log "  Status:   $status_count polls"
        log "  Messages: $messages_count polls"
        log "  Todos:    $todos_count polls"
        log "  Duration: ${SECONDS}s"
        echo ""
        log "Files saved to: $session_dir"
        log "Run 'make debug-analyze' to analyze"
        exit 0
    }
    
    trap cleanup EXIT SIGTERM SIGINT
    
    local last_ports=""
    
    while true; do
        local ports=$(find_opencode_ports)
        
        if [[ -z "$ports" ]]; then
            if [[ -n "$last_ports" ]]; then
                log_warn "No OpenCode instances found, waiting..."
                last_ports=""
            fi
            sleep 2
            continue
        fi
        
        # Demarre les SSE listeners pour les nouveaux ports
        for port in $ports; do
            if [[ -z "${SSE_PIDS[$port]:-}" ]] || ! kill -0 "${SSE_PIDS[$port]}" 2>/dev/null; then
                record_sse_events "$port" "$events_file" &
                SSE_PIDS[$port]=$!
                log_success "Connected to port $port"
            fi
        done
        
        # Arrete les listeners pour les ports disparus
        for old_port in "${!SSE_PIDS[@]}"; do
            if ! echo "$ports" | grep -q "^${old_port}$"; then
                kill "${SSE_PIDS[$old_port]}" 2>/dev/null
                unset SSE_PIDS[$old_port]
                log_warn "Disconnected from port $old_port"
            fi
        done
        
        last_ports="$ports"
        
        # Poll HTTP endpoints
        for port in $ports; do
            # Poll status
            poll_session_status "$port" "$status_file"
            
            # Get session IDs and poll each
            local status=$(curl -s --max-time 5 "http://127.0.0.1:${port}/session/status" 2>/dev/null)
            if [[ -n "$status" && "$status" != "{}" ]]; then
                local session_ids=$(echo "$status" | jq -r 'keys[]' 2>/dev/null)
                for session_id in $session_ids; do
                    poll_session_messages "$port" "$session_id" "$messages_file"
                    poll_session_todos "$port" "$session_id" "$todos_file"
                done
            fi
        done
        
        # Affiche stats en temps reel
        local event_count=$(wc -l < "$events_file" | tr -d ' ')
        printf "\r${GRAY}[%s]${NC} Recording... Events: ${GREEN}%d${NC} | Ports: ${BLUE}%s${NC}    " \
            "$(date +%H:%M:%S)" "$event_count" "$(echo $ports | tr '\n' ' ')"
        
        sleep $POLL_INTERVAL
    done
}

# === Mode Analyze ===

do_analyze() {
    local target_dir="$1"
    
    # Si pas de dir specifie, prend le plus recent
    if [[ -z "$target_dir" ]]; then
        target_dir=$(ls -td "$DEBUG_DIR"/*/ 2>/dev/null | head -1)
    fi
    
    if [[ -z "$target_dir" || ! -d "$target_dir" ]]; then
        log_error "No debug session found. Run 'make debug-record' first."
        exit 1
    fi
    
    echo ""
    log_success "=== OpenCode Debug Analyzer ==="
    log "Analyzing: $target_dir"
    echo ""
    
    # Summary
    if [[ -f "$target_dir/summary.json" ]]; then
        echo -e "${BLUE}=== Summary ===${NC}"
        jq '.' "$target_dir/summary.json"
        echo ""
    fi
    
    # Event types
    local events_file="$target_dir/events.jsonl"
    if [[ -f "$events_file" && -s "$events_file" ]]; then
        echo -e "${BLUE}=== Event Types ===${NC}"
        jq -r '.event.type // "unknown"' "$events_file" 2>/dev/null | sort | uniq -c | sort -rn
        echo ""
        
        echo -e "${BLUE}=== Sample Events (first 5) ===${NC}"
        head -5 "$events_file" | jq -c '.event' 2>/dev/null
        echo ""
    else
        log_warn "No events recorded"
    fi
    
    # Messages structure (pour voir les tools)
    local messages_file="$target_dir/poll-messages.jsonl"
    if [[ -f "$messages_file" && -s "$messages_file" ]]; then
        echo -e "${BLUE}=== Tool Types Found ===${NC}"
        jq -r '.messages[]?.parts[]? | select(.type == "tool") | .tool // "unknown"' "$messages_file" 2>/dev/null | sort | uniq -c | sort -rn
        echo ""
        
        echo -e "${BLUE}=== Sample Tool Part (first) ===${NC}"
        jq -c '[.messages[]?.parts[]? | select(.type == "tool")][0]' "$messages_file" 2>/dev/null | head -1 | jq '.'
        echo ""
    else
        log_warn "No messages recorded"
    fi
    
    # Todos structure
    local todos_file="$target_dir/poll-todos.jsonl"
    if [[ -f "$todos_file" && -s "$todos_file" ]]; then
        echo -e "${BLUE}=== Todo Statuses ===${NC}"
        jq -r '.todos[]?.status // "unknown"' "$todos_file" 2>/dev/null | sort | uniq -c | sort -rn
        echo ""
    fi
    
    # Session statuses
    local status_file="$target_dir/poll-status.jsonl"
    if [[ -f "$status_file" && -s "$status_file" ]]; then
        echo -e "${BLUE}=== Session Status Changes ===${NC}"
        jq -r '.status | to_entries[] | "\(.key): \(.value)"' "$status_file" 2>/dev/null | sort | uniq -c | sort -rn | head -10
        echo ""
    fi
    
    log_success "Analysis complete!"
}

# === Main ===

show_help() {
    echo "OpenCode Debug Tool"
    echo ""
    echo "Usage:"
    echo "  opencode-debug record              Record events in real-time"
    echo "  opencode-debug analyze [dir]       Analyze recorded logs"
    echo "  opencode-debug help                Show this help"
    echo ""
    echo "Output directory: $DEBUG_DIR"
}

case "${1:-help}" in
    record)
        do_record
        ;;
    analyze)
        do_analyze "${2:-}"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        log_error "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
